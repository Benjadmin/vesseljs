<html>

<head>
	<title>Ship in Ocean</title>
	<script src="../build/vessel.js"></script>

	<script src="libs/three.js"></script>
	<script src="libs/STLLoader.js"></script>

	<script src="snippets/Ship3D_v2.js"></script>

	<!-- Upgrading to WaterShader2.js will remove the dependency
	on Mirror.js as well as open up possibilities for visualizing approximate water flows around vessels. -->
	<script src="libs/Mirror.js"></script>
	<script src="libs/WaterShader.js"></script>
	<script src="libs/OrbitControls.js"></script>
	<script src="libs/skybox_from_examples.js"></script>
	<script src="libs/browse_files_Elias_Hasle.js"></script>
	<script src="libs/STLLoader.js"></script>

	<script src="snippets/Patch_interpolation.js"></script>
	<script src="snippets/Playback.js"></script>
	<script src="snippets/Regular_ocean.js"></script>
	<script src="snippets/InsertCatenary.js"></script>
	<script src="snippets/epoch.js"></script>
	<!--<script src="Moving_bodies_Elias_Hasle.js"></script>-->
	<!--<script src="keyboard_arrow_input_Elias_Hasle.js"></script>-->

	<script src="libs/dat.gui.min.js"></script>
	<script src="libs/numeric-1.2.6.min.js"></script>
	<!-- <script src="libs/zingchart.min.js"></script> -->
</head>

<style>
	.button-reload {
		border: none;
		display: inline-block;
		padding: 8px 16px;
		vertical-align: middle;
		overflow: hidden;
		text-decoration: none;
		color: white;
		background-color: black;
		text-align: center;
		cursor: pointer;
		white-space: nowrap
	}

	.hover-red:hover {
		color: #fff !important;
		background-color: #f44336 !important
	}
</style>

<body>
	<script>
		"use strict";

		//Globals
		var renderer, camera, controls, gui, stats;
		var scene, zUpCont, playback, bodies, ocean, ship3D;
		var ship3D, states, epoch, epochEquipments, eletricCable, umbilical;
		var designDimension, floatingStates, eletricCable, line, hangedeletricCable;
		var catenaryFunction;
		var scale;

		var clock = new THREE.Clock();

		(function main() {
			//Renderer setup
			//document.body.style = "overflow: hidden;";
			document.body.style.overflow = "hidden";
			var container = document.createElement("div");
			//container.style = "position: absolute; top: 0; left: 0;"
			Object.assign(container.style, {
				position: "absolute",
				top: 0,
				left: 0,
				width: "100vw",
				height: "100vh"
			});
			document.body.appendChild(container);
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			//renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x99aadd);
			container.appendChild(renderer.domElement);

			//GUI setup (comment out to remove gui)
			gui = new dat.GUI();

			//add report to GUI controller
			var obj = {
				"Click to read paper": function() {
					window.open("https://observablehq.com/d/54d7081bc6ef0429");
				}
			};
			gui.add(obj, "Click to read paper");

			playback = new Playback({
				parentGUI: gui
			});

			//Scene setup:
			scene = new THREE.Scene();
			let sun = new THREE.DirectionalLight(0xffffff, 2);
			sun.position.set(-512, 246, 128);
			scene.add(sun);

			//Ocean size
			let oSize = 2048;

			scene.add(new Skybox(oSize));

			//Use Z up from now on:
			THREE.Object3D.DefaultUp.set(0, 0, 1);
			zUpCont = new THREE.Group();
			zUpCont.rotation.x = -0.5 * Math.PI;
			scene.add(zUpCont);

			// Add the bottom of ocean
			var geometry = new THREE.PlaneBufferGeometry(oSize, oSize, 32);
			var texture = new THREE.TextureLoader().load("textures/bottom.jpg");
			var material = new THREE.MeshBasicMaterial({
				side: THREE.FrontSide,
				map: texture,
				transparent: true, // visible from below
				opacity: 0.65
			});
			var plane = new THREE.Mesh(geometry, material);
			var oceanDepth = 30;
			plane.translateZ(-oceanDepth);
			zUpCont.add(plane);

			//Camera setup
			camera = new THREE.PerspectiveCamera(26, window.innerWidth / window.innerHeight, 1, 1000000);
			let onResize = function() {
				let w = container.clientWidth;
				let h = container.clientHeight;
				renderer.setSize(w, h);
				camera.aspect = w / h;
				camera.updateProjectionMatrix();
			};
			window.addEventListener('resize', onResize, false);
			onResize();
			camera.position.set(0, -oSize * 0.15, -oSize * 0.01);
			camera.translateZ = -oceanDepth / 2;
			camera.lookAt(zUpCont.position);
			zUpCont.add(camera);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			//controls.minDistance = 0;
			controls.maxDistance = 0.5 * oSize;
			controls.enablePan = false;
			controls.maxPolarAngle = 3 * (Math.PI / 4);
			controls.minPolarAngle = 0;
			controls.maxAzimuthAngle = Math.PI / 2;
			controls.minAzimuthAngle = -Math.PI / 2;

			//zUpCont.add(new THREE.AxisHelper(1000));
			zUpCont.add(new THREE.HemisphereLight(0xccccff, 0x666688, 1));

			ocean = new Ocean({
				// parentGUI: gui,
				sunDir: sun.position.clone().normalize(),
				size: oSize,
				segments: 127
			});
			playback.add(ocean);
			zUpCont.add(ocean);

			// Creating Epoch
			epoch = ({
				"position": {
					"x": 50,
					"y": 0,
					"depth": 25,
				}
			});

			var geometrySphere = new THREE.SphereGeometry(1, 32, 32);
			var material = new THREE.MeshBasicMaterial({
				color: 0xffff00,
				opacity: 0.75
			});
			epoch.mesh = new THREE.Mesh(geometrySphere, material);
			[epoch.mesh.position.x, epoch.mesh.position.y, epoch.mesh.position.z] = [
				epoch.position.x, epoch.position.y,
				-(epoch.position.depth + oceanDepth)
			];
			zUpCont.add(epoch.mesh);

			// Straction Equipments
			epochEquipments = ({
				"position": {
					"x": 50,
					"y": 0,
					"depth": 25
				},
				"xmastree": {
					"position": {
						"x": 0,
						"y": 0,
						"depth": 0
					},
					"dimensions": {
						"radius": 1,
						"height": 10
					}
				},
				"well": {},
				"brine_disposal": {},
				"sonar": {},
				"umbilical": {},
				"sub_pump": {
					"position": {
						"x": -10,
						"y": 0,
						"depth": 0
					},
					"dimensions": {
						"length": 1,
						"width": 1,
						"height": 1,
					}
				},
				"brine_subpump": {
					"position": {
						"x": 10,
						"y": 0,
						"depth": 25
					},
					"dimensions": {
						"length": 1,
						"width": 1,
						"height": 1,
					}
				},
				"energy_generator": {},
				"dissolution_parameters": {
					"dissolution_flowrate": 640,
					"dissolution_time": 850
				},
				"co2_flowrate": {
					"flowrate_capacity": 640
				}
			});

			[epochEquipments.xmastree.position.x, epochEquipments.xmastree.position.y, epochEquipments.xmastree.position.z] = [
				epoch.position.x + epochEquipments.xmastree.position.x,
				epoch.position.y + epochEquipments.xmastree.position.y,
				-oceanDepth
			];

			// parameters for simulation
			epoch.simulation = new Epoch(
				epochEquipments.dissolution_parameters.dissolution_flowrate,
				epochEquipments.dissolution_parameters.dissolution_time,
				epochEquipments.co2_flowrate.flowrate_capacity,
			);

			// Adding STL
			var loader = new THREE.STLLoader();
			loader.load('./specs/STL files/xtree.stl', function(geometrySTL) {
				var material = new THREE.MeshPhongMaterial({
					color: 0x303030,
					emissive: 0x494949,
					specular: 0x6b6b6b,
					shininess: 100
				});
				// new THREE.Mesh( geometry, material );

				epochEquipments.xmastree.mesh = new THREE.Mesh(geometrySTL, material);
				[epochEquipments.xmastree.mesh.position.x, epochEquipments.xmastree.mesh.position.y, epochEquipments.xmastree.mesh.position.z] = [
					epochEquipments.xmastree.position.x,
					epochEquipments.xmastree.position.y,
					epochEquipments.xmastree.position.z
				];

				epochEquipments.xmastree.mesh.rotation.set(0, 0, -Math.PI / 2)


				zUpCont.add(epochEquipments.xmastree.mesh);
				// zUpCont.add(new THREE.Mesh(geometrySTL, material));
			});

			var geometry = new THREE.BoxGeometry(
				epochEquipments.sub_pump.dimensions.length,
				epochEquipments.sub_pump.dimensions.width,
				epochEquipments.sub_pump.dimensions.height,
			);
			var material = new THREE.MeshBasicMaterial({
				color: 0x00ff00
			});
			epochEquipments.sub_pump.mesh = new THREE.Mesh(geometry, material);
			[epochEquipments.sub_pump.mesh.position.x, epochEquipments.sub_pump.mesh.position.y, epochEquipments.sub_pump.mesh.position.z] = [
				epoch.position.x + epochEquipments.sub_pump.position.x,
				epoch.position.y + epochEquipments.sub_pump.position.y,
				-(oceanDepth - epochEquipments.sub_pump.dimensions.height / 2)
			];
			zUpCont.add(epochEquipments.sub_pump.mesh);

			var geometry = new THREE.BoxGeometry(
				epochEquipments.brine_subpump.dimensions.length,
				epochEquipments.brine_subpump.dimensions.width,
				epochEquipments.brine_subpump.dimensions.height,
			);
			var material = new THREE.MeshBasicMaterial({
				color: 0xff0000
			});
			epochEquipments.brine_subpump.mesh = new THREE.Mesh(geometry, material);
			[epochEquipments.brine_subpump.mesh.position.x, epochEquipments.brine_subpump.mesh.position.y, epochEquipments.brine_subpump.mesh.position.z] = [
				epoch.position.x + epochEquipments.brine_subpump.position.x,
				epoch.position.y + epochEquipments.brine_subpump.position.y,
				-(oceanDepth - epochEquipments.brine_subpump.dimensions.height / 2)
			];
			zUpCont.add(epochEquipments.brine_subpump.mesh);

			// Object for Eletric Cables
			eletricCable = ({
				"states": {},
				"geometry": {},
				"anchorPointOnShip": {
					"x": 0,
					"y": 0,
					"z": 0
				},
				"anchorPointSeaBottom": {
					"x": epochEquipments.xmastree.position.x,
					"y": epochEquipments.xmastree.position.y,
					"z": -oceanDepth
				},
				"anchorLineGeometry": {},
				"hangedMooring": {},
				// "radialDistance": 200,
				// "mooringAngle": 45,
				"breakingLoad": 200,
				"anchorLength": 200,
				"horizontalForce": 200, // Horizontal Force on the ship (kgf)
				"w": 10, // Mooring line density (kg/m)
				"oceanDepth": oceanDepth,
			});

			// Object for Umbilical
			umbilical = ({
				"states": {},
				"geometry": {},
				"anchorPointOnShip": {
					"x": 0,
					"y": 0,
					"z": 0
				},
				"anchorPointSeaBottom": {
					"x": epochEquipments.sub_pump.mesh.position.x,
					"y": epochEquipments.sub_pump.mesh.position.y,
					"z": -oceanDepth
				},
				"anchorLineGeometry": {},
				"hangedMooring": {},
				// "radialDistance": 200,
				// "mooringAngle": 45,
				"breakingLoad": 300,
				"anchorLength": 200,
				"horizontalForce": 200, // Horizontal Force on the ship (kgf)
				"w": 5, // Mooring line density (kg/m)
				"oceanDepth": oceanDepth,
			});

			Vessel.loadShip( /*"specs/ship_specifications/PX121.json"*/
				/*"specs/ship_specifications/blockCase.json"*/
				/*"specs/ship_specifications/prismaticHull.json"*/
				"specs/ship_specifications/top-down.json",
				function(ship) {
					states = ship.designState.clone();
					ship3D = new Ship3D(ship, {
						stlPath: "specs/STL files",
						upperColor: 0x33aa33,
						lowerColor: 0xaa3333,
						hullOpacity: 1,
						deckOpacity: 1,
						objectOpacity: 1
					});
					zUpCont.add(ship3D);

					// Setting the position of the ship
					ship3D.position.x = -50;

					// For the Lines Purpose
					designDimension = ship.structure.hull.attributes;
					floatingStates = states.calculationParameters;

					states.continuous.eletricCable = {};
					eletricCable.states = states.continuous.eletricCable;

					//Point of mooring line on ship (m, m, m)
					//Trim added to correct misplacement of mooring node
					eletricCable.anchorPointOnShip.x = designDimension.LOA / 4 + ship3D.position.x;
					eletricCable.anchorPointOnShip.y = -designDimension.BOA / 4 + ship3D.position.y;
					eletricCable.anchorPointOnShip.z = ship3D.position.z;

					// Creating the mooring line 3D Object
					eletricCable.materialLine = new THREE.LineBasicMaterial({
						color: 0xffffff,
						linewidth: 1
					});

					// Insert geometry
					eletricCable.geometry = new THREE.Geometry();
					eletricCable.object = new THREE.Line(eletricCable.geometry, eletricCable.materialLine);

					catenaryFunction = new InsertCatenary(eletricCable.anchorPointOnShip, eletricCable.anchorPointSeaBottom, eletricCable, 100);
					// eletricCable.anchorLineGeometry.geometry.verticesNeedUpdate = true;
					// zUpCont.add(eletricCable.anchorLineGeometry);

					//Point of mooring line on ship (m, m, m)
					//Trim added to correct misplacement of mooring node
					umbilical.anchorPointOnShip.x = designDimension.LOA / 4 + ship3D.position.x;
					umbilical.anchorPointOnShip.y = designDimension.BOA / 4 + ship3D.position.y;
					umbilical.anchorPointOnShip.z = ship3D.position.z;

					// Creating the mooring line 3D Object
					umbilical.materialLine = new THREE.LineBasicMaterial({
						color: 0xffff00,
						linewidth: 1
					});

					// Insert geometry
					umbilical.geometry = new THREE.Geometry();

					catenaryFunction = new InsertCatenary(umbilical.anchorPointOnShip, umbilical.anchorPointSeaBottom, umbilical, 100);
					// eletricCable.anchorLineGeometry.geometry.verticesNeedUpdate = true;
					// zUpCont.add(eletricCable.anchorLineGeometry);

					// Gui interface
					scale = gui.addFolder("Dissolution Parameters");
					scale
						.add(epochEquipments.dissolution_parameters, "dissolution_flowrate", 500, 700)
						.step(1)
						.onChange(function(newValue) {
							epochEquipments.dissolution_parameters.dissolution_flowrate = newValue;
						})
						.name("Rate (m3/h)");
					scale
						.add(epochEquipments.dissolution_parameters, "dissolution_time", 730, 1095)
						.step(1)
						.onChange(function(newValue) {
							epochEquipments.dissolution_parameters.dissolution_time = newValue;
						})
						.name("Time (days)");
					scale.open();
					scale = gui.addFolder("CO2 Flow");
					scale
						.add(epochEquipments.co2_flowrate, "flowrate_capacity", 500, 700)
						.step(1)
						.onChange(function(newValue) {
							epochEquipments.co2_flowrate.flowrate_capacity = newValue;
						})
						.name("Rate (m3/h)");
					scale.open();
					scale = gui.addFolder("Simulation");
					scale
						.add(epoch.simulation, 'time', 0, 100).listen()
						.name("Time (weeks)");
					scale.open();

				});

			playback.play();

			requestAnimationFrame(animate);
		})();

		function animate(millitime) {
			var t = clock.getElapsedTime();
			epoch.simulation.updateVolume(t)

			let playing = playback.update();

			//Disable this to freeze water when not playing
			if (!playing) {
				ocean.water.material.uniforms.time.value += 1 / 60;
			}

			// epoch.mesh.geometry.radius += 0.01;
			if (epoch.mesh.scale.x < 20) {
				epoch.mesh.scale.x = epoch.simulation.radius;
				epoch.mesh.scale.y = epoch.simulation.radius;
				epoch.mesh.scale.z = epoch.simulation.radius;
				epoch.mesh.geometry.verticesNeedUpdate = true;
			}

			ocean.water.render();

			renderer.render(scene, camera);
			requestAnimationFrame(animate);
		}

	</script>
</body>

</html>
